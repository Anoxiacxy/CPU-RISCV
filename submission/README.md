# CPU-RISCV

### 仓库地址

https://github.com/Anoxiacxy/CPU-RISCV.git

### 频率

可以支持在 100MHz下运行，但150MHz 及以上频率暂不支持， WNS 为 -10.197ns

### 测试情况

~~因为未知原因，本项目**并不支持**在FPGA上运行。可以加载到FPGA中，但是只会输出一个字符，且后面的字符都是乱码。~~

~~但是在**模拟程序上实测可以通过所有在短时间内能够跑完的测试点**（可以跑完`pi.c`），但一些测试点比如 `heart.c`因为运行时间太长而并没有测试。~~

项目可以运行在 FPGA 上，但是读入有一点小问题。对于自己设置的一个额外测试点，input.c。测试的结果如下：

#### input.c

```c
// input.c
#include "io.h"
int main() {
    char c;
    for (int i = 1; i < 70; i++)
        c = inb(), outb(c), outb(' '), outl(c), outb('\t');
}
```

#### input.in

```
123456789
abcdefghijklmnopqrstuvwxyz
!@#$%^&*()_+-={}[]\|;:'"<,>.?/
```

测试结果：

#### input.out

```
  32      32    1 49    2 50    3 51    4 52    5 53    6 54    7 55    8 56    9 57
 10     a 97    b 98    c 99    d 100   e 101   f 102   g 103   h 104   i 105   j 106   k 107   l 108   m 109   n 110   o 111   p 112   q 113   r 114   s 115   t 116   u 117   v 118   w 119   x 120   y 121   z 122
 10     ! 33    @ 64    # 35    $ 36    % 37    ^ 94    & 38    * 42    ( 40    ) 41    _ 95    + 43    - 45    = 61    { 123   } 125   [ 91    ] 93    \ 92    | 124   ; 59    : 58    ' 39    " 34    < 60    , 44    > 62    . 46    ? 63    / 47
```

可以看到程序刚开始**读到了两个未知原因出现的空格**，暂时没有调试的头绪。

其余测试点在 100MHz 的频率下运行有着以下的表现。因为读入原因，我对部分测试点的源代码进行了修改，让其能够直接获取需要读入的数据。这样修改过后的代码可以直接在 ./riscv/testcase 里找到。

| 测试点         | 运行时间   | 备注                                                   |
| -------------- | ---------- | ------------------------------------------------------ |
| array_test1    | 0.000000   | 答案正确，但无法读入，需修改 b[i] = i + 1 作为读入     |
| array_test2    | 0.000000   | 答案正确，但无法读入，需修改 pb[0][i] = i + 1 作为读入 |
| basicopt1      | 0.031250   | 答案正确                                               |
| bulgarian      | 1.062500   | 答案正确                                               |
| expr           | 0.015625   | 答案正确                                               |
| gcd            | 0.015625   | 答案正确                                               |
| hanoi          | 1.093750   | 答案正确                                               |
| heart          | 503.250000 | 答案正确                                               |
| lvalue2        | 0.015625   | 答案正确                                               |
| magic          | 0.031250   | 答案正确                                               |
| manyarguments  | 0.015625   | 答案正确                                               |
| multiarray     | 0.031250   | 答案正确                                               |
| pi             | 1.390625   | 答案正确                                               |
| qsort          | 4.062500   | 答案正确                                               |
| queens         | 0.968750   | 答案正确                                               |
| statement_test | 0.015625   | 答案正确                                               |
| superloop      | 0.015625   | 答案正确，但无法读入，需要修改 N = 6 作为读入          |
| tak            | 0.015625   | 答案正确，但无法读入，需要修改 a=18;b=12;c=6; 作为读入 |
| testsleep      | -          | sleep时间偏短，b-a实际测试中为 99991432                |
| uartboom       | 0.656250   | 答案正确                                               |

### 分支预测 （ctrl_branch.v）

分支预测使用的 BHT + BTB的策略，用了一个2048行 的**BHT**记录每条指令的跳转历史，另外单独使用 32 行的一个**BTB**记录跳转指令具体跳转到的地址。

BHT的正确率更高，而BTB直接可以获取下一条指令，可以节省更多的周期。

如果一条指令既不在BHT中也不再BTB中，将直接 pc + 4.

### 指令缓存 (cache_i.v)

使用了64行的缓存，每行储存4个字节，刚好缓存了一条指令。

### 数据缓存 (cache_d.v)

使用了64行的缓存，每行储存4个字节，含有 dirty 标记。

参考了（wu_qing_157）的写法。使用额外的一个 write buffer 缓存要写入内存的数据，write buffer 可以**分多次**将数据写入到内存。这种策略的优势是让对于当前操作没有影响的写操作**尽可能在内存读写空闲**的时候完成，减少了对于当前指令读取和运算所需要的数据读取的占用。

### 缓存控制逻辑（ctrl_ram.v）

有限执行所有可能的内存读取操作，当没有内存读取操作的时候执行指令读取操作，在指令读取的间隙时间执行写操作，如果写操作也没有，将使用上一次读取指令的地址 + 4作为指令执行预取。指令预取可以让程序在顺序执行，且暂时**没有 ICacheHit** 的时候保持稳定的**四周期**即可读到一条可以执行的指令。




